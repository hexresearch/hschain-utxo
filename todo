* implement let-pattenrs for repl in the style of
    
    (a, b) = getPair

* prohibit recursive type definitions

* no type error on wrong expression with tuples and pat-match

-- xorCol :: Color -> Color -> Bool
xorCol Red (Red, Red) = True
xorCol Green (Green, Green) = True
xorCol Blue (Blue, x) = True
xorCol _ _ = False
-- xorCol Red Green = False
-- xorCol Green Red = False

* Refine type-errors in patterns. The problem is located in case-alternative
   but the line number points at the argument of the function.
  Can we make it better?

f :: Bool -> Int
f x = case x of
  True    -> 1
  "False" -> 2
  False   -> 4


* consider name collisions of fresh vars within user module loading stage

* consider name collision of fresh vars inside AlgorithmW
   make dedicated separate constructor for FreshVars
  parametrise everything by type of Var-name

* big number of tuples-constructors user types - type-checkers blows up

* wrong type check error for tuples mismatch

   f :: (a, b, c) -> a
   f x = case x of
    (a, b, c) -> a

  it gives type mismatch of (Tuple3 a b c -> a) does not match (Tuple3 a b c -> a)

* fails to parse negative numbers

   w = -3 -- gives parse error

   [1, -2, 3] -- gives parse error

* make modules, imports (build from several source files)

* check performance (intensive task)

* refactor for separation of reduction of syntax-sugar and execution
   make small separate subset language on which we execute (extended lambda-calculus)

* optimize lambda-reductions

* docs-update

* mystirious constructor Bool. Try in repl
  
    Bool && True


