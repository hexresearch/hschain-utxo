* add bottoms to G-machine or some mechanism of throwing errors

* define core language

* update hschain version many instance of CryptoHashable are already defined there

* implement let-pattenrs for repl in the style of
    
    (a, b) = getPair

* prohibit recursive type definitions

* pattern matching compiler reorders constructors in alphabetical order.
   In many cases it can lead to counter intuitive errors in pattern matching.
   Consider fix order reaarangement. Pattern compiler should keep original order
  of constructors. Case where problem is highlighted:

  Here We have pattern with constructor Bob it goes last but due to alphabetical order
  it goes first and the whole expression becomes Name -> Bool instead of more intuitive Color -> Bool

data Color
  = Red
  | Green
  | Blue

data Name = John | Bob | Wanessa

xorCol Red     = True
xorCol Wanessa = True
xorCol Green   = True
xorCol Bob     = False

* consider name collisions of fresh vars within user module loading stage

* consider name collision of fresh vars inside AlgorithmW
   make dedicated separate constructor for FreshVars
  parametrise everything by type of Var-name

* big number of tuples-constructors user types - type-checkers blows up

* make modules, imports (build from several source files)

* check performance (intensive task)

* refactor for separation of reduction of syntax-sugar and execution
   make small separate subset language on which we execute (extended lambda-calculus)

* optimize lambda-reductions

* docs-update
